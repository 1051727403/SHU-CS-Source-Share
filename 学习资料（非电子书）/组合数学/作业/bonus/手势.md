# 解锁手势个数

## 可行解共有以下三个约束条件：

> 1. 可行解至少包括四个点。
> 2. 任意点在团中只会标记一次，若在某一个点上存在线段较差，这个点也只会被标记一次。
> 3. 三点共线时，中间的点需要已经被标记。

使用**dfs暴力搜索**算法。详细代码如下:

```python
import math
vis = [[False, False, False],
       [False, False, False],
       [False, False, False]]

ans = [0, ] * 9


def dfs(n: int, count: list, x: int, y: int):
    global vis
    global ans
    if n == 1:
        count[0] += 1
        for i in range(0, 3):
            for j in range(0, 3):
                if vis[i][j] is True:
                    ans[i * 3 + j] += 1
        return
    for i in range(0, 3):
        for j in range(0, 3):
            # 如果这个点没有访问过
            if vis[i][j] is False:
                distance = math.sqrt(math.pow((i - x), 2) + math.pow((j - y), 2))
                # 此点相邻(横、斜1格) 或 日字格
                if distance <= math.sqrt(2) or abs(distance - math.sqrt(5)) <= 1e-10:
                    vis[i][j] = True
                    dfs(n - 1, count, i, j)
                    # 恢复现场，下面同
                    vis[i][j] = False
                # 此点连成一条直线(中间隔一点)
                elif vis[(i + x) // 2][(j + y) // 2] is True and (
                        abs(distance - 2) <= 1e-10 or abs(distance - 2 * math.sqrt(2)) <= 1e-10):
                    vis[i][j] = True
                    dfs(n - 1, count, i, j)
                    vis[i][j] = False


if __name__ == '__main__':
    sum_ = 0
    print("-" * 30)
    print("手势点个数情况如下所示")
    print("-" * 30)
    for n in range(4, 10):
        count = [0]
        for x in range(0, 3):
            for y in range(0, 3):
                vis = [[False, False, False],
                       [False, False, False],
                       [False, False, False]]
                vis[x][y] = True
                dfs(n, count, x, y)
        sum_ += count[0]

        print("当手势点个数为%d时有%d种情况" % (n, count[0]))

    print("总计有%d种情况" % sum_)
    print()
    print("-" * 30)
    print("手势点中包含每个点的情况如下所示")
    print("-" * 30)
    for i in range(0, 9):
        print("第%d个点共出现了%d次" % (i + 1, ans[i]))
    print("-" * 30)
```

代码运行结果如下图所示：

<img src="https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20220910170713267.png" alt="image-20220910170713267" style="zoom: 33%;" />

此运行结果也符合预期输出，根据对称性：

- 1 3 7 9出现次数相同

- 2 4 6 8出现次数相同

由于1 3 7 9分别与3个点相邻 2 4 6 8分别与5个点相邻 5号点与8个点相邻，因此出现次数定性分析(5) > (2 4 6 8) > (1 3 7 9)，代码运行结果与此推论相符。