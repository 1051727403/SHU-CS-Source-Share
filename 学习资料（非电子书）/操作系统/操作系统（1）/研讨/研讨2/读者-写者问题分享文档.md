# 读者-写者问题

## 基本要求

1. 允许多个读者进程同时对文件执行读操作

2. 某一时刻只允许一个写者进程向文件中写信息

3. 任一写者在完成写操作之前不允许其他读者或写者工作

4. 写者执行写操作前直到已有的读者和写者全部退出

## 互斥关系

1. 读进程与写进程之间  互斥

2. 读进程与读进程之间  不互斥

3. 写进程与写进程之间  互斥



## 基本实现思路(未经完善的版本,思路铺垫)

1.设置整数变量readercount记录当前有几个读进程在访问文件

2.**第一个读进程**	加锁

3.**最后一个读进程**  解锁

![image-20221011094853813](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221011094853813.png)

对于写进程而言，当写进程访问临界资源文件的时候需要使用PV操作把临界区夹起来。当第一个写进程进入后，通过P操作，开始写文件。第二个写进程到来时会被卡在P(rw)这里了，直到第一个写进程写完文件后，对rw进行V操作，释放文件资源，第二个写进程才可以继续写操作。

读者进程相对而言复杂一点。在一个读进程读文件之前，需要先检查有无其他的读进程正在进行读操作。如果检查到没有其他读进程，也就是判断readcount等于0时，那么它作为第一个读进程，对文件进行加锁操作，并且计数变量加1。当它读完文件之后，计数变量减1，并且判断此时这个读进程是不是唯一的读进程，如果是唯一的读进程，需要对文件进行解锁。这样设置的话，当第一个读进程到来时，它对文件加锁，使得写进程无法访问，同时其它的读进程的readcount不等于0，也可以直接访问文件。

### 弊端

但是这样设置有一个弊端，如果两个读进程并发执行，假设他们同时到达判断readcount是否为0的语句，1号读进程来了判断为true，接着执行P(rw)，但是假设它没有来得及做readcount++操作，并且此时时间片分给了2号读进程，由于readcount还没来得及修改，2号读进程此时的readcount也是0，判断为true，所以它也会进行P(rw)操作，这两个读进程先后执行P(rw)，从而使得第二个读进程出现阻塞。

## 1.读者优先

对于这种现象的解决方法是设置reader_mutex互斥信号量，把readcount当做临界资源，用来保证每一个读进程对于readcount的访问是互斥的，此时。还是刚刚那种情况，对于reader_mutex执行P操作只允许一个读进程访问readcount，当2号读进程到来时，会等到1号读进程释放readcount时才能访问readcount，这样就不会出现上述的堵塞现象。

![image-20221011101325970](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221011101325970.png)

这就是**读者优先**算法，由于读进程之间没有互斥的限制，哪怕此时写进程排队在读进程之前，也是读进程优先访问文件。设想一个极端情况，当读进程一个接着一个到来时，第一个来的读者进程会P(rw)对文件上锁，但没有最后一个读进程解锁，写进程无法访问文件。导致只有无论排队顺序，只有当没有读进程在排队的时候，写进程才可以访问。这样的算法为读者优先，读进程优先级高于写进程，只有当不存在读进程时，写进程才可以访问文件。只要有读进程还在读，写进程就要一直阻塞等待，因此写进程可能出现“饿死”现象。

------

## 2.写者优先

![image-20221011101407825](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221011101407825.png)

而**写者优先算法**是指，当写者到来时，队列中此写者之前的读者仍继续读操作，但之后到来的读进程都阻塞，直到队列中不存在写进程在排队。之后到来的写进程会“插队“，也就是说，即使后续读进程排队在写进程前面，这个读进程也必须等到队列中没有写进程时才可以继续读文件。实现写者优先需要多设置一些变量，额外设置了3个变量，分别是记录写进程排队的数量的整形变量、对于写进程互斥访问的信号量、以及实现写进程优先互斥的信号量。

写者优先算法的读者进程相比于读者优先算法，只是多了一步在进入前申请read权限。而写者进程比较复杂，当写者进程到来时，先判断此时还有没有其他写者，如果存在其他写者的话，那么就限制了其他读者的权限。此时已经有权限的读者进程，也就是已经执行过P(read)这行代码的读进程就不管了，但之后再来的读者进程就会被P(rw)操作堵塞。这就像疫情封校突然下通知文件限制跨片区流动，已经跨了片区的同学就不管了，再来的同学除非有蓝码，否则就不放行。当写者进程离开的时候，如果写者队列为空就给予读权限,对read进行V操作。此时读者进程就可以来读了。

至于为什么要设置writer_mutex，实际上是和设置reader_mutex原理是一样的，为了保护writercount计数变量，防止writercount来不及修改时时间片用完，两个写进程都if判断成true了，导致堵塞。

### 情况模拟

接下来模拟一种情况。

1号写者(正在写文件)----1号读者----2号写者----2号读者----3号写者

当1号写者到来，由于writecount为0，不会对read进行P操作，他顺利执行到写文件的部分，而1号读者来了readcount等于0，并且1号写者已经对rw做了P操作，所以1号读进程会堵塞在`if(readcount == 0) P(rw)`这里。此时2号写者来了，writercount不为0，会对read进行P操作，限制了读取权限。再来一个2号读者，他会被P(read)阻塞。如果这个时候来了一个3号写者，按照排队的先后顺序，应该是2号读者比3号写者先执行，因为是2号读者比3号写者先来的。但是由于此时2号读者没有read权限，还被卡在P(read)这里。所以3号写者比2号读者优先，并且read权限只有当队列中没有写者才会赋予，只要有写者在排队，读者就都无法读。这就是**写者优先**算法。

------

## 3.读写公平

为了实现读写公平，我们新增了一个信号量w【新增的地方在代码中已标注】。其中，读者和写者进程的地位是完全平等的，即无论是读者还是写者进程，都按它们到达的时间先后决定访问临界资源的优先次序。

![image-20221011104758849](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221011104758849.png)

### 情况模拟

1. **读者**先执行，则读者进程先对w执行p操作，此时w值变为0
   1. 另一个读者进程也来执行
      1. 如果此时第一个读者进程还没有执行到对w执行v操作时，则此时另一个读者进程在对w执行p操作后陷入阻塞状态并加入阻塞队列
      2. 如果此时第一个读者进程已经对w执行了v操作，那么另一个读者进程此时也可以执行且不会被阻塞，此时两个读者进程可以不互斥的执行
   2. 有写者进程来执行
      1. 如果此时第一个读者进程还没有执行到对w执行v操作时，则此写者进程必然回陷入阻塞态，加入阻塞队列
      2. 如果此时第一个读者进程已经对w执行了v操作，此时写者进程中的p(w)操作失效，然而由于第一个读者进程已经对rw执行了p操作，写者进程在对rw执行p操作时仍然会陷入阻塞状态
2. **写者**先执行，则写者进程先对w执行p操作，此时w值变为0
   1. 写者进程未释放w时，读者进程执行p(w)操作后必然陷入阻塞，无法继续执行
   2. 其余写者进程如想执行，同理也不能执行

> **小结：**
>
> 1. 写者先执行时，其余写者和读者就不可能执行。
> 2. 读者先执行时
>    1. 另一个读者也执行，先后执行完p(w)和r(w)后才能同时执行读文件操作。
>    2. 写者不可能执行。



------



## 伪代码实现总结

### 1.读者优先

#### **信号量、控制变量设置**

```cpp
semaphore rw = 1; // 用于实现对文件的互斥访问 表示当前是否有进程访问文件
int readcount = 0; // 记录当前有几个读进程在访问文件
semaphore reader_mutex = 1; // 用于保证对readcount变量的互斥访问
```

#### **写者**

```cpp
writer(){
  while(1){
    P(rw);
    写文件....
    V(rw);
  }
}
```

#### **读者**

```cpp
reader(){
	while(1){
    
		P(reader_mutex); // 各读进程互斥访问reader_count
    if(readcount == 0)
      P(rw);  // 第一个读进程负责加锁
    readcount++; // 读者在读数+1
    V(reader_mutex);
    
    读文件...
      
    P(reader_mutex); // 各读进程互斥访问count
    readcount--; // 读者在读数-1
    if(readcount == 0)
      V(rw);  // 最后一个一个读进程负责解锁
    V(reader_mutex);
	}
}
```

### 2.写者优先

#### 信号量、控制变量设置

```c
semaphore rw = 1; // 用于实现对文件的互斥访问 表示当前是否有进程访问文件
semaphore read = 1; // 用于实现“写进程优先”互斥信号量
int readercount = 0; // 记录当前有几个读进程在访问文件
int writercount = 0; // 记录当前有几个写进程在排队
semaphore reader_mutex = 1; // 用于保证对readcount变量的互斥访问
semaphore writer_mutex = 1; // 用于保证对writercount变量的互斥访问
```

#### 写者

```cpp
writer(){
  while(1){
    P(writer_mutex); // 各写进程互斥访问writercount
    if(writercount != 0) // 如果当前写者队列不为空则申请读者优先
      P(read); 
  	writecount++; // 写者数量+1
    V(writer_mutex);
    
    P(rw);
    写文件....
    V(rw);
    
    P(writer_mutex); // 各写进程互斥访问writercount
    writecount--; // 写者数量-1
    if(writecount != 0) // 如果写者队列为空则允许读者进行操作
      V(read);
    V(writer_mutex); // 各写进程互斥访问writercount
  }
}
```

#### 读者

```cpp
reader(){
	while(1){
		P(read);  // 申请读取权限
    
		P(reader_mutex); // 各读进程互斥访问reader_count
    if(readercount == 0)
      P(rw);  // 第一个读进程负责加锁
    readercount++; // 读者在读数+1
    V(reader_mutex);
    
    读文件...
      
    P(reader_mutex); // 各读进程互斥访问count
    readercount--; // 读者在读数-1
    if(readercount == 0)
      V(rw);  // 最后一个一个读进程负责解锁
    V(reader_mutex);
	}
}
```

### 3.读写公平

#### 信号量、控制变量设置

```c
semaphore rw = 1; // 用于实现对文件的互斥访问 表示当前是否有进程访问文件
int readercount = 0; // 记录当前有几个读进程在访问文件
semaphore reader_mutex = 1; // 用于保证对readcount变量的互斥访问
semaphore w = 1; // 实现读写公平
```

#### 写者

```c
writer(){
  while(1){
    P(w); 
    P(rw);
    写文件....
    V(rw);
    V(w); // 各写进程互斥访问writercount
  }
}
```

#### 读者

```c
reader(){
	while(1){
		P(w);
		P(reader_mutex); // 对count变量的检查和赋值无法一气呵成加锁
    if(readercount == 0)
      P(rw);  // 第一个读进程负责加锁
    readercount++; // 读者在读数+1
    V(reader_mutex);
    V(w);
    读文件...
      
    P(reader_mutex); // 各读进程互斥访问count
    readercount--; // 读者在读数-1
    if(readercount == 0)
      V(rw);  // 最后一个一个读进程负责解锁
    V(reader_mutex);
	}
}
```

------



## 代码实现总结

此部分使用C语言中的线程库与信号量库，给出了三种算法的实现。

### 1.读者优先

```c
#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>

#define P sem_wait
#define V sem_post
#define rw &rw_
#define mutex &mutex_

const int READER_NUM = 2;
const int WRITER_NUM = 20;
const double SLEEP_TIME = 1;
sem_t rw_;
sem_t mutex_;

static int readercount = 0;

void *reader(void *arg)
{
    int id = *((int *)arg);
    while (1)
    {
        P(mutex);
        if (readercount == 0) // 第一个读进程负责加锁
            P(rw);
        readercount++;
        V(mutex);
        
        printf("%d号读者读取\n", id);

        P(mutex);
        readercount--;
        if (readercount == 0)
            V(rw);
        V(mutex);
    }
}
void *writer(void *arg)
{
    int id = *((int *)arg);
    while (1)
    {
        // sleep(1);
        P(rw);
        // sleep(SLEEP_TIME);
        printf("%d号写者修改\n", id);
        V(rw);
    }
}

int main()
{
    sem_init(rw, 0, 1);
    sem_init(mutex, 0, 1);

    pthread_t readers[READER_NUM];
    pthread_t writers[WRITER_NUM];

    
    
    for (int i = 0; i < WRITER_NUM; i++)
    {
        pthread_create(&writers[i], NULL, writer, &i);
    }

    for (int i = 0; i < READER_NUM; i++)
    {
        pthread_create(&readers[i], NULL, reader, &i);
    }
    pthread_exit(0);

    return 0;
}

```

### 2.写者优先

```c
#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>

#define P sem_wait
#define V sem_post
#define rw &rw_
#define reader_mutex &reader_mutex_
#define writer_mutex &writer_mutex_
#define read &read_


const int READER_NUM = 20;
const int WRITER_NUM = 2;
const double SLEEP_TIME = 1;

sem_t rw_;
sem_t reader_mutex_;
sem_t writer_mutex_;
sem_t read_;

static int readercount = 0;
static int writercount = 0;

void *reader(void *arg)
{
    int id = *((int *)arg);
    while (1)
    {
        P(read); // 申请读取权限

        // 互斥操作访问readercount 
        P(reader_mutex); 
        if (readercount == 0)
            P(rw);
        readercount++;

        V(reader_mutex);
        printf("%d号读者读取\n", id);
        sleep(SLEEP_TIME);
        P(reader_mutex);
        
        // 互斥操作访问readercount 
        readercount--;
        if (readercount == 0)
            V(rw);
        V(reader_mutex);
    }
}

void *writer(void *arg)
{
    int id = *((int *)arg);

    while (1)
    {
        // 写进程互斥访问writercount 写队列中有写进程则不给read权限
        P(writer_mutex);
        if(writercount != 0)
            P(read);
        writercount++;
        V(writer_mutex);


        P(rw);
        printf("%d号写者修改\n", id);
        V(rw);

        // 写进程互斥访问writercount
        P(writer_mutex);
        writercount--;
        if(writercount != 0)
            V(read);
        V(writer_mutex);
    }
}

int main()
{
    // 初始化信号量
    sem_init(rw, 0, 1);
    sem_init(reader_mutex, 0, 1);
    sem_init(writer_mutex, 0, 1);
    sem_init(read, 0, 1);

    // 初始化读者、写者
    pthread_t readers[READER_NUM];
    pthread_t writers[WRITER_NUM];

    for (int i = 0; i < READER_NUM; i++)
    {
        pthread_create(&readers[i], NULL, reader, &i);
    }
    
    for (int i = 0; i < WRITER_NUM; i++)
    {
        pthread_create(&writers[i], NULL, writer, &i);
    }

    pthread_exit(0);

    return 0;
}
```

### 3.读写公平


```c
#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>

#define P sem_wait
#define V sem_post
#define rw &rw_
#define mutex &mutex_
#define w &w_

const int WIRTER_NUM = 1;
const int READER_NUM = 1;
const int SLEEP_TIME = 1;

int count = 0;
sem_t rw_;
sem_t w_;
sem_t mutex_;

void *writer(void *arg)
{
    int id = *((int *)arg);
    while (1)
    {
        sleep(SLEEP_TIME);
        P(w); //新增
        P(rw);
        printf("%d: 写文件.\n", id);
        V(rw);
        V(w); //新增
    }
}

void *reader(void *arg)
{
    int id = *((int *)arg);
    while (1)
    {
        sleep(SLEEP_TIME);
        P(w); //新增
        P(mutex);
        if (count == 0)
        {
            P(rw);
        }
        count++;
        V(mutex);
        V(w); //新增
        printf("%d: 读文件.\n", id);
        P(mutex);
        count--;
        if (count == 0)
        {
            V(rw);
        }
        V(mutex);
    }
}

int main()
{
    sem_init(rw, 0, 1);
    sem_init(mutex, 0, 1);
    sem_init(w, 0, 1);

    pthread_t writers[WIRTER_NUM];
    pthread_t readers[READER_NUM];

    for (int i = 0; i < WIRTER_NUM; i++)
    {
        pthread_create(&writers[i], NULL, writer, &i);
    }

    for (int i = 0; i < READER_NUM; i++)
    {
        pthread_create(&readers[i], NULL, reader, &i);
    }

    pthread_exit(0);

    return 0;
}
```

