# 操作系统报告

# 题目1

![image-20221119143111521](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221119143111521.png)

## 1.1

### 什么是微内核

内核是管理系统资源的操作系统的核心部分。它是计算机应用程序和硬件之间的桥梁，内核在计算机启动boot引导启动程序之后就会被加载。 

而微内核是内核的分类之一，作为内核，它管理所有系统资源。不同于宏内核，在微内核中，**用户服务**和**内核服务**是在不同的地址空间中实现的。用户服务保存在**用户地址空间**，内核服务保存在**内核地址空间**，这样也减少了内核的大小和操作系统的大小。微内核设置了**用户态**与**内核态**两种状态，关于这两种状态之间的讨论将在问题二中详细展开。

微内核将核心功能模组化，划分成几个独立的模块，各自运行，形成服务。需要特权的进程，只有基本的线程管理，内存管理和进程间通信等，这个部份，由一个简单的硬体抽象层与关键的系统调用组成。其余的服务行程，则移至使用者空间。

  

![image-20221120110301120](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221120110301120.png)





### 微内核包括哪些基本功能

由于内核是操作系统的核心部分，因此内核仅被用于用于处理最重要的服务。在这个微内核体系结构中，只有最重要的服务在内核中，其余的操作系统服务存在于系统应用程序中。微内核具体提供以下具体功能：

1. 进程管理

对于进程的调度，在进程管理中设置多个进程的优先级队列，能够将制定优先级的进程从进程队列中取出并进行运行。

而对于进程的通信而言，由于所有服务进程都各自在不同地址空间内运行，因此在微核心架构下，不能像宏内核一样直接进行函数调用。在微核心架构下，微内核间建立一个行程间通讯机制，通过消息传递的机制来让服务进程间相互交换讯息，调用彼此的服务，以及完成同步。

2. 内存管理

微内核中配置最基本的第几存储器管理机制，例如实现将用户空间的逻辑地址变化为内存空间的物理地址的页表机制和地址变换机制等，这些依赖于硬件的部分都放在微内核中。

3. 中断处理

当中断发生时，内核会将中断捕获，进行对应的前期处理，如中断现场保护，识别中断类型等等。将中断信息转换为消息后发送给服务器，再由服务器调用相关程序进行处理。

## 1.2

### 和宏内核相比，微内核有哪些优点？

1. 系统可扩展性强

它很容易**扩展**，即如果要添加任何新服务，它们将被添加到用户地址空间，因此不需要在内核空间中进行修改。

2. 增加了系统的可靠性

让服务之间各自独立，可以减少系统之间的耦合度，易于实作与除错，也可增进可移植性。可以避免单一服务失效而造成整个系统崩溃。即使某项服务出错，内核只需要重新启动这个服务即可，不致于影响服务的功能，使系统稳定度增加。同时，系统也可以根据需要，替换或新增某些服务进程，结构更加灵活。

尽管在用户地址空间中运行的C/S和服务之间的通信是通过消息传递建立的，降低了微内核的执行速度。操作系统**不受影响**，因为用户服务和内核服务是隔离的，因此如果任何用户服务失败，它不会影响内核服务。

 

### 存在哪些问题？

微内核最大的问题就在于执行效率不高，而导致效率不高的原因主要取决于

#### 上下文切换

当由操作系统决定进行进程间的切换时，操作系统就会执行一些底层代码，即所谓的上下文切换。上下文切换在概念上很简单:操作系统要做的就是为当前正在执行的进程保存一些寄存器的值，并为即将执行的进程恢复一些寄存器的值。这样一来，操作系统就可以确保最后执行return-from-trap指令时，不是返回到之前运行的进程，而是继续执行另一个进程。

为了保存当前正在运行的进程的上下文，操作系统会执行一些底层汇编代码，来保存通用寄存器、程序计数器，以及当前正在运行的进程的内核栈指针，然后恢复寄存器、程 序计数器，并切换内核栈，供即将运行的进程使用。通过切换栈，内核在进入切换代码调用时，是一个进程(被中断的进程)的上下文，在返回时，是另一进程(即将执行的进程) 的上下文。当操作系统最终执行从陷阱返回指令时，即将执行的进程变成了当前运行的进程。至此上下文切换完成。

#### 效率降低：

时间片轮转的方式，使得多个任务利用一个CPU执行成为可能，但是保存现场和加载现场，也带来了性能消耗。完成一次客户对操作系统提出的服务请求时，需要利用消息实现多次交互和进行用户态与核心态直接的切换。

如果上下文切换的次数过多，会导致CPU在操作系统控制下，并不能专注于计算，而像个“搬运工”，频繁在寄存器和进程队列之间转换。更多的时间花在了线程切换，而不是真正工作的线程上。直接的消耗包括CPU寄存器需要保存和加载，系统调度器的代码需要执行。间接消耗在于多核cache之间的共享数据。 

## 1.3

### 查询资料介绍 两个微内核

1. Minix

Minix是一种基于微内核架构的类UNIX计算机操作系统，是一个免费的开源操作系统。它很好的体现出了微内核的设计思想，即：高度可靠、灵活和安全。它基于在内核模式下运行的微型微内核，而操作系统的其余部分作为许多隔离的、受保护的进程在用户态下运行。它运行在x86和ARM CPU上，与NetBSD兼容，运行数以千计的NetBSD包。

全套Minix除了启动的部分以汇编语言编写以外，其他大部分都是用C语言编写。分为：核心、存储器管理及文件系统三部分。Minix在设计之初，为了使程序简化，它将程序模块化，如文件系统与存储器管理，都不是在操作系统核心中运作，而是在用户空间运作。至Minix 3这个大版本时，连IO设备都被移到用户空间运作。

2. PikeOS

PikeOS是一种商业硬实时操作系统，他也是微内核架构的典型代表。它提供基于分离内核的管理程序，具有多种逻辑分区类型。PikeOS 的一个关键特性是能够在同一计算平台上同时安全地执行具有不同安全级别的应用程序。这是通过软件分区对这些应用程序进行严格的空间和时间隔离来完成的。软件分区可以被视为具有预分配权限的容器，可以访问内存、CPU时间、I/O和预定义的操作系统服务列表。

PikeOS适用于许多其他操作系统，它使用户能够根据不同行业的高质量、安全和安保标准，为IOT物联网构建可认证的智能设备。PikeOS 是为航空航天、国防、汽车、运输、工业自动化、医疗、网络基础设施和消费电子领域具有认证需求的安全关键应用而开发的。

### 两个宏内核

1. OpenBSD

OpenBSD是一个以安全为中心的，免费开源的类Unix 操作系统，基于BSD。OpenBSD使用宏内核架构，其开发团队为OpenBSD开发的软件包如PF防火墙、OpenSSH，在其他操作系统中随处可见。OpenBSD的安全增强功能，内置的加密功能和pf包过滤器使它在安全领域应用广泛，例如作为防火墙、入侵检测系统和虚拟专用网网关，OpenBSD也因此被称为世界上最安全的操作系统。

2. AIX

AIX也是宏内核操作系统，它的名字来源于名称来自先进交互执行系统(Advanced Interactive executive)，AIX级别的逻辑卷管理正逐渐被添加进各种自由的UNIX风格操作系统中。值得一提的是，将AI应用于国际象棋，并曾经打败当时国际象棋世界冠军的计算机深蓝使用的操作系统就是AIX。

## 1.4

### 自己设计操作系统内核的话，选择微内核还是宏内核？

就我个人而言，我会选择微内核。

关于软件设计中微内核和宏内核优劣的争论曾经非常激烈，两者间如何选择，也曾引发Minix与Linux作者之间的辩论，即Tanenbaum–Torvalds debate。而今天的许多通用操作系统中，Linux仍采用微内核，而MacOSX、Windows都采用混合内核设计。

在微内核设计中，所有的功能都被尽可能从内核中移除，而是交付给独立的操作空间，这些操作空间则通过进入内核态相互传递消息。另一方面，在宏内核设计中，内核和操作进程共享空间，消息在进程之间直接传递，而不需要在内核之间进行。

只从有益于开发的角度而言，微内核架构对于开发人员更加友好，单个服务分离的低耦合设计思想也比较符合软件工程的理念，也和用目前公司中很热门的“微服务”的潮流很相近。尽管在宏内核架构当中，内核管理着CPU调度，内存管理，文件管理和系统调用等各模块的的工作，由于用户服务和内核服务被实现在同一空间中，这样在执行速度上要比微内核快。但是在牺牲部分的执行速度换取更稳定的工作与更低的开发难度显然是值得的。





简单的讲宏内核就是操作系统是个大管家，几乎包办一切，用户应用程序的需求直接向内核提出就行；微内核更像一个代理人，几乎所有的驱动、文件系统全部运行在与用户应用程序平级的用户模式下。

![image-20221120131013557](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221120131013557.png)

# 题目2

![image-20221119143130263](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221119143130263.png)

## 2.1

首先，需要搞清楚区分各种状态的原因。

为了使得程序更快地运行，最“简单粗暴“想法是直接在CPU上运行程序。如果按照这种思路设计，一个程序的生命周期为：

当OS希望启动程序运行时，它会在进程列表中为其创建一个进程条目，为其分配一些内存，将程序代码加载到内存中，找到main函数等入口点，跳转到那里，并开始运行用户的代码。而当这个进程运行结束时，操作系统会将其内存释放，并且从进程列表中清除。

然而，这种”简单粗暴“的方法会在虚拟化CPU时产生问题。

如果只运行一个程序，操作系统怎么能确保程序不做访问受限内存等危险操作，同时仍然高效地运行？例如，如果我们希望构建一个在授予文件访问权限前检查权限的文件系统，就不能简单地让任何用户进程向磁盘发出I/O。如果这样做，一个进程就可以读取或写入整个磁盘，这样所有的针对于磁盘的保护都会失效。

因此，需要做出多种状态的划分。

### 核心态

在内核态下，操作系统可以访问机器的全部资源。在此状态下，运行的代码可以做它喜欢的事，包括特权操作，如发出I/O请求和执行所有类型的受限指令。

### 用户态

在用户态下，应用程序不能完全访问硬件资源，在用户态下运行的代码将受到限制。例如，在用户态下运行时，进程不能发出I/O请求。这样做会导致处理器引发异常，操作系统可能会终止进程。

通常来说，以下三种情况会导致用户态到内核态的切换

1.系统调用

2.异常

3.外围设备的中断

这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。也正因为有了核心态与用户态的区分，特权指令与普通指令的区分才有意义。

### 特权指令

指令是应用程序向系统发出的命令或命令。操作系统中的指令分为两类——特权指令和非特权指令。

特权指令只能在核心态下运行。如果特权指令试图在用户模式下执行，则该指令将被忽略并被视为非法指令。在执行特权指令时，操作系统可以确保在将控制权转移到任何用户应用程序之前将定时器设置为中断。因此，如果计时器被中断，操作系统可以重新获得控制权。典型的特权指令有清理内存指令、上下文切换指令等等。

### 普通指令

而普通指令是仅仅在用户模式下执行的指令，常用的特权指令有读取系统时间、进行算数运算等等。而最重要的普通指令当之无愧是trap指令，trap指令是用户态转变为核心态的重要接口。

关于特权指令与普通指令，有一点需要区分：

直接切换到内核模式的指令是特权指令，因为该指令是独立调用的，而不是通过系统调用、中断或外围设备中断。

而切换到内核模式的系统调用指令是非特权指令，因为该指令是在通过系统调用时，执行了trap指令时调用的。

![image-20221119221600152](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221119221600152.png)

总而言之，特权指令是仅仅在核心态下执行的指令，普通指令是仅仅在用户模式下执行的指令。由用户态切换到核心态有三种方式，其中最为重要的是系统调用。

## 2.2

### 系统调用

系统调用是程序发出的切换到内核态的请求。它允许内核小心的向用户程序暴露某些关键功能，例如访问文件系统、创建和销毁进程、与其他进程通信，以及分配更多内存等等。其中最具体的系统调用就是问题四中提到的fork()、wait()等等。

在介绍内核态与用户态时提到了由用户态切换到内核态有3种方式，其中最重要的方式就是系统调用。

系统调用是用户态与内核态之间的重要接口。而系统调用从底层角度看，能进入内核态的原因是各种系统调用都调用了trap指令与return-from-trap指令。要执行系统调用，程序必须执行trap指令。该指令同时跳入内核并将特权级别提升到内核态。一旦进入内核，系统就可以执行任何需要的特权操作，操作系统从而为调用进程执行所需的工作。而当系统调用结束后，操作系统调用return-from-trap指令，该指令返回到发起调用的用户程序中，同时将特权级别降低，由内核态回到用户态。

![image-20221119231228925](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221119231228925.png)





即然trap指令作为进入到内核态的接口，并且所有的系统调用都需要执行trap指令，对于不同的系统调用而言，trap指令如何知道在操作系统运行哪些代码呢？

显然，发起系统调用的进程不能指定要跳转到的地址，这样做让程序可以跳转到内核中的任意位置。如果可以由发起系统调用的进程指定位置，则对于因此内核必须谨慎地控制在陷阱上执行的代码。

硬件通过提供不同的执行状态来协助操作系统。还提供了trap指令来进入内核态和return-from-trap指令从内核态回到用户态，并且提供了一些指令。让操作系统告诉硬件trap table在内存中的位置。内核在启动时设置trap table，由于操作系统在内核态下运行，因此可以根据需要自由配置机器硬件。操作系统此时告诉硬件在发生某些异常事件时要运行哪些代码。例如，发生异常、外围设备终端、系统调用时的硬件执行位置，当硬件的trap table被设置结束后，并且硬件知道在发生系统调用和其他异常事件时要跳转到哪一段代码处。


### 库函数

库调用是使用编程库提供的功能的请求。在使用特定的库调用时，首先要导入相关的库。在导入相关库，调用库函数时即将对应的库函数连接到了程序之中。在 C 编程中，程序员可以通过在程序中包含头文件来调用库函数。预处理器指令 #include有助于包含头文件。

库函数实例有很多，如使用各类常用的头文件中的函数，使用stdio.h头文件包含执行输入和输出操作的各种函数。使用printf函数格式化输出发送到标准输出设备，使用scanf函数从标准输入设备读取格式化输入等等。

### 系统调用与库函数的区别

主要区别在于系统调用是对内核访问资源的请求，其中涉及到调用trap指令进入内核态；而库调用是使用编程库中定义的函数的请求。

具体而言，man文档对于系统调用的函数与库函数进行了明确的分类，将系统调用函数放到了第2章，而将库函数放入了第3章。

![image-20221119224844761](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221119224844761.png)

系统调用fork()、wait()等等看起来完全就像C语言中的库函数，而系统如何区分这二者呢？

尽管fork()、wait()等与C语言库函数形式相似，但在执行这些系统调用函数时，会执行trap指令进入内核态之中。其中，无论是对于 open()还是提供的其他系统调用，库都使用与内核一致的调用约定来将参数放、系统调用号放入约定好的栈或寄存器中，之后执行trap指令。而在trap指令之后的代码准备好返回值，并将控制权返回给发出系统调用的程序。



![image-20221119225726729](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221119225726729.png)

![image-20221119225748477](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221119225748477.png)

# 题目3

![image-20221119105523072](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221119105523072.png)

## 3.1

### MLFQ算法的设计思想

多级反馈队列进程调度算法，即MLFQ算法的算法规则如下:

- 规则 1:如果 A 的优先级 > B 的优先级，运行 A(不运行 B)。
- 规则 2:如果A的优先级 = B的优先级，轮转运行A和B。
- 规则 3:工作进入系统时，放在最高优先级(最上层队列)。
- 规则 4:一旦工作用完了其在某一层中的时间配额(无论中间主动放弃了多少次 CPU)，就降低其优先级(移入低一级队列)。
- 规则 5:经过一段时间 S，就将系统中所有工作重新加入最高优先级队列。

### MFLQ算法的必要组成部分

多级反馈队列(MLFQ)是对于时间片轮转算法和优先级调度算法的优化，它主要着眼于2方面的问题

- 周转时间
- 响应时间

其中的核心问题在于：没有工作长度这一先验知识，该如何设计调度程序来减少同时减少响应时间与周转时间？

对于相应时间而言，由于MLFQ使用到了时间片，并且根据规则3，工作进入系统时默认放入最上层队列。

在基础的最短作业优先算法(SJF)中，我们是已经有了哪一些作业是长度较短的这一先验知识，因此可以使用SJF算法来减少周转时间。这对于抢占式的SJF算法更为明显，如果在某个作业正在运行的过程中出现了新作业，如果我们没有新作业与正在运行作业的长度的先验知识，那我们就不清楚作业的预期运行时间，SJF算法的前提就消失了。

首先，它要优化周转时间，这通过先执行短工作来实现。然而，操作系统通常不知道工作要运行多久，而这又是SJF(抢占式或非抢占式)算法所必需的。其次,MLFQ希望给等待交互的终端型用户很好的交互体验，因此需要降低响应时间。然而，像轮转这样的算法虽然降低了响应时间，周转时间却很差。所以这里的问题是:通常我们对进程的一无所知，应该如何构建调度程序来降低周转时间与响应时间?调度程序如何在运行过程中学习进程的特征，从而做出更好的调度决策?

### 分析具体调度过程

多级反馈队列算法(MLFQ)中每一个作业的优先级并非固定不变，而是根据作业的行为调整它的优先级。

例如，如果一个工作不断放弃CPU去等待键盘输入，这是交互型进程的可能行为MLFQ因此会让它保持高优先级。相反，如果一个工作长时间地占用CPU，MLFQ会降低其优先级。通过这种方式，MLFQ在进程运行过程中学习其行为，从而利用工作的历史来预测它未来的行为。

在作业中，既有运行时间很短、频繁放弃CPU的交互型工作，也有需要很多CPU时间、响应时间却不重要的长时间计算密集型工作。对于这两种类型的工作应当综合考虑。





#### 例子1

此处的例子，很好的展示MLFQ如何近似SJF算法。在这个例子中，有两个工作:

A是一个长时间运行的CPU密集型工作，B是一个运行时间很短的交互型工作。假设A执行一段时间后B到达。

#### TODO插入这个例子的表格

**到达时间 时间片 期待运行时间 开始时间 队列级别**

下图展示了这种场景的结果。A为长时间运行的CPU密集型工作，在最低优先级队列执行(用黑色表示)。B在时间T=100时到达，并被加入最高优先级队列(用灰色表示)。由于它的运行时间很短，只有 20ms，经过两个时间片，在被移入最低优先级队列之前，B执行完毕。然后A在最低优先级Q0继续运行。

通过这个例子可以看出，MLFQ的一个主要目标:如果不知道工作是短工作还是长工作，那么就在开始的时候假设其是短工作，并赋予最高优先级。如果确实是短工作，则很快会执行完毕，否则将被慢慢移入低优先级队列，而这时该工作也被认为是长工作了。通过这种方式，MLFQ近似于SJF，从而使得整体获得比较好的周转时间。

<img src="https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221119135119451.png" alt="image-20221119135119451" style="zoom:33%;" />

#### 例子2

再说再说



## 3.2

### 死锁的概念

与操作系统紧密相关的一个例子是如果某一个计算机系统只存在一台打印机与一台输入设备，若此时进程P1占用了输入设备，同时提出了使用打印机的请求，但此时打印机正在被进程P2占用，如果在P2进程没有释放掉打印机之前，又提出请求申请正在被P1占用的输入设备。此时P1、P2进程会相互无休止等待下去，均无法继续执行。这样，这两个进程就陷入了死锁。

<img src="https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221119194638422.png" alt="image-20221119194638422" style="zoom: 25%;" />

### 死锁产生的必要条件

- 互斥:线程对于需要的资源进行互斥的访问(例如一个线程抢到锁)。
- 持有并等待:线程持有了资源(例如已将持有的锁)，同时又在等待其他资源(例如，需要获得的锁)。
- 非抢占:线程获得的资源(例如锁)，不能被抢占。
- 循环等待:线程之间存在一个环路，环路上每个线程都额外持有一个资源，而这个资源又是下一个线程要申请的。

死锁的产生必须同时具备以上四个必要条件，如果上述四个条件之一不具备，那么死锁将不会产生。所以若想要使得系统避免发生死锁，就提供给我们思路，即破坏4个必要条件之一。或者当死锁产生时，有能力进行恢复。

### 死锁安全状态和安全序列之间的关系



### 实现的数据结构

- Avaliable[m]--可利用资源向量。含有m个元素的数组，Available[j]=k表示系统中第j类资源数为k个，其初值是系统中所配置的该类全部可用资源数目，其数值随该类资源的分配和回收而动态地改变。

- Max[n,m]--最大需求矩阵。n\*m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求。Max[i,j] = k表示进程i对j类资源的最大需求数为k。

- Allocation[n,m]--分配矩阵。n\*m的矩阵，它定义了系统中每一类资源当前已分配给每一个进程的资源数， Allocation[i,j] = k表示进程i已分得j类资源的数目为k个。

- Need[n,m]--需求矩阵。n*m的矩阵，它定义了当前系统的n个进程要想完成工作，还需要各类资源的数目，它表示每个进程尚需的各类资源数，Need[i,j] = k表示进程i还需要j类资源k个。

  上述的三个矩阵存在以下关系：

  ![image-20221120214042856](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221120214042856.png)

  在银行家算法中，默认Need矩阵为已知条件，而这在现实情况中并不成立，详细分析过程在适用条件会展开分析。

- Request--进程Pi的请求向量Request。一个含有m个元素的向量，它表示进程i对各类资源的需求情况。如果Request[j] = K，表示进程Pi需要K个Rj类型的资源。

  安全性检查算法也是银行家算法的步骤之一，其中需要用到两个向量：

- Work：它表示系统可提供给进程继续运行所需的各类资源数目，它含有m个元素

- Finish:它表示系统是否有足够的资源分配给进程，使之运行完成。开始时Finish［i］:= False; 当有足够资源分配给进程时，再令Finish［i］:= True。

### 算法过程

假设进程Pi提出资源请求Request[j] = k

1. 若Request[i]<= Need[i,j]便转向执行步骤2;否则认为出错。
2. 若Request[i]<= Available[i,j]便转向执行步骤3;否则表示系统尚无足够的资源分配，让Pi等待。
3. 系统假设将Pi所要求的资源分配给Pi，并对数据结构做如下修改:

![](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221120214132215.png)

4. 系统执行安全性算法，检测此次资源分配后，系统是否处于安全状态。若安全才正式将资源分配给进程Pi,以完成本次分配;否则，本次试探分配作废，恢复原来的资源分配状态，让Pi等待。



#### 安全性检查算法部分

1. 在执行安全算法开始时，分别设置两个向量

![image-20221120215104913](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221120215104913.png)

2. 从进程集合中找到一个能满足以下条件的进程:

![image-20221120215421311](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221120215421311.png)

3. 进程Pi获得资源后，可以顺利执行，直至完成，并释放分配给它们的资源，故应执行:

![image-20221120215644387](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221120215644387.png)

此时转向步骤2

4. 若此时安全序列中已经包含了所有进程，则表示系统处于安全状态；否则系统处于不安全状态。

　　由此可见，**安全性算法实际是银行家算法的一部分**，为当前系统找到一个安全序列，确保此刻的系统的分配状态能够保证内存中的进程全部顺利完成。

### 算法适用条件

银行家算法本质上属于死锁避免中的一种，通过系统调度防治系统进入不安全状态。然而类似于银行家算法的调度算法在避免死锁时有很大的局限性，因此通过调度来避免死锁并不是广泛的通用方案。

1. 类似于在介绍MFLQ算法时提到的SJF最短作业优先算法需要有作业预期运行时间的先验知识，此处的银行家算法也需要必须有所有进程最大资源需求的**先验知识**。

2. 要求进程数固定，它正在执行时不能启动其他进程。这一点使得银行家算法有一种“**静态**”的感觉，当银行家算法运行的那一刻，好像按下了照片的快门进行了定格，此后的过程必须严格的按照银行家算法执行。在真实的操作系统中，这一点很明显是不可能做到。

3. 要求资源数量保持固定；在没有发生死锁的可能性的情况下，任何资源都不得因任何原因而下降。

4. 没有考虑进程的运行时间，它允许在有限时间内批准所有请求，但是1秒钟，1天，1个月都是有限的时间，显然这是不合理的。







# 题目4

![image-20221119143229613](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221119143229613.png)

### 什么是哲学家进餐问题

哲学家就餐问题是一个著名的并发问题，它由Dijkstra提出来并解决。

<img src="https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221119145921820.png" alt="image-20221119145921820" style="zoom:25%;" />

假定有5位“哲学家”围着一个圆桌。每两位哲学家之间有一把餐叉(一共5把)。哲学家有时要思考一会，不需要餐叉;有时又要就餐。而一位哲学家只有同时拿到了左手边和右手边的两把餐叉，才能吃到东西，餐叉的竞争以及随之而来的同步问题。

一个有趣的点，功利一点来说，哲学家进餐问题是就业或者读研面试是经常要考到的部分，尤其是工作时的后端开发岗位，也是知名的“八股”题目之一。



### 哲学家进餐C实现

解决哲学家问题，此处使用了信号量机制。



PV操作均为原子操作，原子操作不会被进程调度打断，这种操作一旦开始就会一直运行到结束，而不会有任何的上下文切换。这也就保证了S的值在机器将其翻译成汇编语句，在寄存器上进行加1、减1操作时是连贯的。

申请资源使用P操作，即wait申请资源当信号量的值S.value < 0时，表示该资源已经分配完毕，需要调用block()原语使进程从运行态变为阻塞态，并把当前进程挂到信号量S的等待队列当中。

![image-20221119160748220](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221119160748220.png)

而释放资源需要用到V操作，当S.value <= 0时，表示当前仍有等待该资源的进程被阻塞在信号量S的等待队列当中，调用wakeup()原语将S.L中的第一个进程从阻塞态变为就绪态。

![image-20221119160811845](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221119160811845.png)

#### PV操作解决互斥问题

解决死锁问题的关键在于对临界资源的保护，在哲学家进餐问题之中，临界资源是叉子，每一只叉子被左边与右边的两个哲学家竞争。

![image-20221119162209896](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221119162209896.png)

1.设置互斥信号量mutex，并设初值为1。

2.在访问临界资源之前，执行p(mutex)，把mutex的值-1，表示当前有进程正在访问临界资源。

3.在结束访问之后，执行v(mutex)，把mutex的值+1，表示访问临界资源的进程访问结束。



信号量是有一个整数值的对象，可以用两个函数来操作它。在POSIX标准中，是sem_wait()和sem_post()，即分别对应着P操作与V操作。为了调用方便，使用C语言的define语句直接将POSIX提供的对应函数定义为P、V操作。在main函数中，针对5个哲学家分别创建了5个线程。叉子为临界资源，在初始化时都设置相应信号量值为了1。并且在最后使用pthread_join语句将分配出去的5个进程资源进行回收。

![image-20221119160111872](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221119160111872.png)





对于每一个哲学家而言，他们的基本循环如下，他们进行思考--取叉子--吃饭--放叉子的过程。

![image-20221119162755207](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221119162755207.png)

如果哲学家 p 希望用左手边的叉子，他们就调用 left(p)。类似地，右手边的叉子就用 right(p)。模运算解决了最后一个哲学家(p = 4)右手边叉子的编号问题，就是餐叉 0。

关键的挑战就是如何实现 getforks()和 putforks()函数，保证没有死锁，没有哲学家会饥饿，并且并发度更高。

一种错误的思路是，为了拿到叉子，我们依次访问每把叉子——先左手边的，然后是右手边的。结束就餐时再将叉子释放掉。虽然如此操作可以实现对于叉子的互斥访问，但是这样的操作会导致死锁的产生。

假设每个哲学家都拿到了左手边的叉子，他们此时都会阻塞，并且一直等待另一个叉子。具体来说，当0、1、2、3、4五位哲学家分别拿到了序号对应的0、1、2、3、4五只叉子时，此时所有的餐叉都被占有了，所有的哲学家都阻塞着，并且等待另一个哲学家占有的餐叉。

![image-20221119163154819](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221119163154819.png)

![image-20221119163031251](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221119163031251.png)

解决上述问题最简单的方法，就是修改某个或者某个哲学家的取餐叉顺序。此处改变了4号哲学家的策略，不同于其他哲学家，4号哲学家先拿右手边的叉子，后拿左手边的叉子。所以不会出现每个哲学家都拿着一个叉子，卡住等待另一个的情况，此时破坏了死锁的循环忙等。

代码的具体运行结果如下，代码在此题中的之前介绍的代码片段的基础上，使用PV操作，添加了对于stdout标准输出的互斥访问，使得同时只可以有1个哲学家线程访问stdout标准输出这一临界资源。

![image-20221119170856375](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221119170856375.png)

程序运行结果如上图所示，3号哲学家拿到fork 0之后，fork 4被4号哲学家先取走，此时3号哲学家等待4号哲学家进餐完毕后才可以取到fork 4，完成进餐。

# 题目5

![image-20221118205018970](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221118205018970.png)

## 5.1

### fork

fork函数通过复制调用fork的进程，产生一个新的进程。新产生的进程为子进程，调用fork函数的进程是父进程。子进程不会从main()函数开始执行，而是从fork()系统调用返回。

对于fork函数而言，当一个进程调用fork函数后，通过系统调用的方式创建子进程，系统先为子进程分配资源，例如存储数据和代码的空间，然后把父进程的所有值都复制到新的子进程中。子进程的运行环境是从父进程中fork一份资源，拷贝了相同的环境，但由系统创建PCB时给予一个新的pid。此处的“拷贝”大多数情况可以理解为编程语言中说的“深拷贝”，即把相关变量在子进程的内存中创建，它们的地址值不同于父进程的原始值地址。父进程和子进程运行在不同的地址空间中。在fork结束之后，父进程和子进程的内存空间会有相同的内容。对于其中一个进程的内存写入、文件映射并不会影响到另一个进程。

子进程并不是完全拷贝了父进程。具体来说，虽然它拥有自己的地址空间(即拥有自己的私有内存)、寄存器、程序计数器等，但是它从fork()返回的值是不同的。父进程获得的返回值是新创建子进程的PID，而子进程获得的返回值是0。正是因为这样的差别，就很容易处理为父子进程这两种情况编写不同逻辑的代码。

尽管大部分子进程对于父进程的拷贝是”深拷贝“,但仍有些特例。这里举一个与我们所学内容比较相近的例子，在下学期的《操作系统（2）》涉及到文件管理的时候很有可能会遇到。子进程继承父进程文件描述符，这也就意味着，打开父进程打开一个文件之后，fork一个子进程，父子进程均向这个文件内写入内容。

![image-20221118203636238](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221118203636238.png)

运行结果如下图所示，尽管此文件描述符是父进程在fork子进程之前创建的，由于子进程继承了父进程的文件描述符，此处的继承是“浅拷贝”，因此父子进程都可以对同一个文件进行写操作。

![image-20221118203832979](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221118203832979.png)

关于fork的介绍此处再提一个我个人认为有趣的点，虽然与系统调用的知识点无关。在OS系统调用中一般说的是父进程fork出子进程，其中的主语是“父进程”；而github上一般说fork别人的仓库，这个主语是“子仓库”。



### exec

首先想要纠正一点描述不严谨，准确的说，exec族函数并非系统调用，execve函数才应当叫做系统调用。在回答第二题时曾经也提到过，man文档中第二个部分man的2号章节提供的是内核提供的系统调用，3号章节提供的是由库提供的函数。正如下图exec族函数execl、execlp等等属于man文档的3号章节，而execve函数属于man文档的2号章节。

![image-20221119213642612](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221119213642612.png)

![image-20221119213708878](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221119213708878.png)

根据man文档，exec族函数，例如execl、execlp等等，其实都是execve函数的前端，即调用这些exec函数实际上是调用了execve函数，只不过是exec族函数更好的封装了各种参数，方便我们的调用。exec族函数通过一个新的进程镜像来替代当前函数。exec族函数包含以下几种变体：execl()、execle()、execlp()、execv()、execvp()。exec这个系统调用可以让子进程与父进程运行不同的程序。



当进程调用 exec 族函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的起始处开始执行。调用 exec 族函数并不创建新进程，所以调用 exec 族函数前后该进程的 PID 并不改变。

exec族函数执行程序与直接在shell中执行命令是不一样的，在shell中直接执行命令会新建一个进程运行此程序。

execlp函数的作用是运行可执行文件，优先在环境变量中搜索，所以此处不需要把pwd的完整路径写出，此函数也可以添加执行文件时附加的参数。pwd是一个shell built-in command，本质是运行了/bin/pwd，即bin目录下的可执行文件，在shell中的命令都是可执行文件的映射，这也体现了Linux中“万物皆文件”的设计哲学。

exec()会从可执行程序中加载代码和静态数据，并用它覆写自己的代码段等静态数据，堆、栈及其他内存空间也会被重新初始化。然后操作系统就执行该程序，将参数通过 argv 传递给该进程。因此，它并没有创建新进程，而是直接将当前运行的程序替换为此处使用exec运行的程序。



而execve函数与main函数由很大的联系，此部分介绍放到下一题处具体讨论



### wait

父进程调用wait系统调用来等待并监听子进程状态的改变。根据man文档，这里所说的的状态改变有多种情况，具体为：

- 子进程终止
- 子进程被信号暂停
- 子进程被信号恢复

父进程暂停系统的执行，直到子进程之一终止，wait系统调用会在子进程运行结束后才会返回。通过这样的操作，即使父进程本身应当先运行结束，也会等到子进程运行结束，然后再wait()返回。调用wait系统调用成功时，wait返回值为停止的子进程的pid，失败时，返回值为-1。

本质上，执行wait(&wstatus)等同于执行waitpid(-1, &wstatus, 0)。而我们在之前做实验时，对于wait的功能只用到了使用wait子进程结束这一种状态，即wstatus参数设置为NULL，调用wait(NULL)，默认使得父进程等待子进程的结束这一状态改变，而不是其他状态。

对于被终止的子进程而言，调用wait系统调用可以使得系统释放掉与子进程相关联的资源；而不调用wait系统调用的话，如果父进程比子进程先执行结束，那么被终止的子进程就成为了僵尸进程。一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作，对于init进程，他循环的进行wait操作，从而保证子进程的结束。

### exit

exit系统调用会通过向进程发送SIGCHLD信号的方式，立即停止调用它的进程。所有属于这个进程的文件描述副都将被关闭，这个进程的所有的子进程都将被pid为1的init进程所继承。exit函数原型如下，其中的status为返回给进程的状态值。

### getpid

getpid系统调用会返还调用这个函数的进程的pid。

pid是进程标识符，每个进程有唯一的pid。它是进程运行时系统分配的，存储在PCB的内部。在进程运行时，PID是并不会改变的，但是进程终止后PID标识符就会被系统回收，就可能会被继续分配给新运行的程序。





## 5.2

### main函数完整格式

main函数的完整格式为：int main(int argc, char *argv[], char *envp[])。

其中的参数需要很好的解释一下，便于理解main函数与exec系统调用的的关系。argc为argument count，argv为argument vector，分别是参数个数，参数数组。此处的argv是一个指向有argc + 1个char类型数组的指针，他是一个指向数组的指针。它指向的的位置是含有argc + 1个指针的指针数组，这个指针数组指向char类型的参数，这个指针数组的第一个指针argv[0]指向这个C文件本身的文件名，最后一个指针argv[argc]指向null。这也解释了argv指向的长度为什么是argc + 1个。而argc最小值为1，即如果并不向C最终的二进制文件传入参数是，唯一的一个参数是文件本身。

有趣的是，argv数组最后一个虽然指向为空，如果人为的制造指针指向偏移，可以发现argv之后的指针指向正是环境变量。使用下面的程序进行验证。而第三个变量envp指向的是环境变量指针数组。

![image-20221119103554607](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221119103554607.png)

其中第8行的i的范围设置为 i <= argc + 3的原因是仅仅验证想法，展示出结果。运行结果如下：

![image-20221119002640185](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221119002640185.png)

观察上图结果，当执行./test teststr时，由编号1可看到argc值为2，即./test与teststr两个，根据之前的分析可明确argv数组指向长度为argc+1，此处为3，并且argv[0]指向文件名./test，最后一个指针argv[2]指向空指针。并且当我们认为制造指针地址偏移时(此处为多偏移了三个单位)，可以看到指针指向了各种环境变量，例如我电脑上的文件默认编码格式UTF-8，用户名root，登录名root等等。下图在shell中输入env命令，截取了部分环境变量，也可以看出前三行一一对应。

![image-20221119003115073](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221119003115073.png)

### main函数入口参数与exec关系

首先，正如之前在介绍exec族函数时所说，exec族函数共六个，均为execve函数的前端，即exec族函数调用后最终结果均为调用execve函数，execve函数原型如下。

int execve(const char *filename, char \*const argv[], **char \*const envp[]);

与main函数的函数参数相同，在调用execve函数时，argv[0]应该指向要执行的文件名称，envp指向环境变量，用键值对的形式存储，具体写法可以参考介绍main函数部分时，输入shell命令env后的输出内容。需要注意的是，argv与envp数组最后一定都要指向空指针。

此处对比main函数的完整格式：int main(int argc, char *argv[], char *envp[])。

因此，当调用exec族6个函数中的一个，他们作为execve函数的前端，会再次调用execve函数。execve函数参数中的的argv、envp两个参数即可以传递给文件名为filename的那个程序的main函数，这也就完成了执行其他程序的功能。

### **TODO：此处可以补充一个思维导图**

### main函数返回值与系统调用wait的关系

exit也与C语言的return语句有关。exit函数的函数原型为void exit(int status)。C语言在return的值如果可以类型转换为int，就和执行系统调用exit()相同，并且把return的那个值作为参数返还给操作系统。exit(0)表示正常退出，exit(x)（x不为0）都表示异常退出。

若使用返回语句，则返回值会用作隐式调用exit()的参数。值零和EXIT_SUCCESS指示成功终止，值EXIT_FAILURE指示不成功终止。

### TODO：此处缺少与wait的关系

### main函数入口参数与返回值和shell语言内置变量的关系

main函数的入口参数中的argv实际上与shell语言内置变量\$1、\$2等等一一对应，其中的1、2即为第1个参数、第2个参数等等。而main函数的返回值也与用shell语言内置变量$?对应。



下面运行了一个测试的C语言程序，其最终执行return 0。\$?记录了上一条执行后的命令的返回值，使用shell的$查看上一次执行结果的返回值可知为0，即return本质调用了exit(0)。此处也可以观察打红框绿色箭头看出来，此处的绿色箭头是我使用的zsh提供的展示返回值的功能。

![image-20221118235027581](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221118235027581.png)

而当我修改C语言程序，将其return值改为10时，可以看到我的zsh提示返回值也变为了10，由于0为成功返回，10返回值一场，因此会有X的错误提示。

![image-20221119100719629](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221119100719629.png)

## 5.3

### 写一个上机时使用到这5种系统调用的程序

### 多分支

上机时最让我印象深刻的程序为创建进程树的程序，此程序创建出了进程家族树，很好的展示了父子进程之间的关系。

![image-20221119104737615](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221119104737615.png)



![image-20221119104150059](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221119104150059.png)

![image-20221119104156080](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221119104156080.png)



子进程的运行环境是从父进程中fork一份资源，拷贝了相同的环境，但由系统创建PCB时给予一个新的pid。在这个程序中，子进程对于父进程的资源，变量i进行了fork，这个拷贝可以理解为编程语言中说的“深拷贝”。把相关变量在子进程的内存中创建，它们的地址值不同于父进程的原始值地址。所以在子进程中修改i不会影响父进程中的i。

pid为10511的进程是执行的shell程序，他是运行二进制文件程序的父进程，它的pid不会随着多次运行代码而改变。pid为13814进程是负责运行二进制文件的进程，此二进制文件由c语言编译后产生获得。反复运行此程序时，虽然pid每次各不相同，但是执行结果的顺序与逻辑关系不变。此程序的执行方式也类似于DFS，对于进程家族树进行前序遍历，也体现出进程家族树“树”的数据结构特点。

### 单分支

而如果使用wait()使得父进程等待子进程的停止，即可将这个进程家族树修改为单分支结构。因此修改父进程部分的逻辑，当只要wait函数监控到有一个子进程运行结束，就退出循环，这样就不会产生新的子进程，完成单分支进程树的要求。

![image-20221119105207223](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221119105207223.png)

按照上述代码修改，进程的创建与消亡又类似于栈的方式，父进程先创建后后终止，子进程后创建先终止。即栈的“先进后出”。具体顺序如下图左红色箭头部分。

![image-20221119105044886](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221119105044886.png)

![image-20221119105054455](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221119105054455.png)

值得注意的是，第一行的my father’s pid is所输出的进程号10511仍与多分支进程家族树中相同，原因是这两问虽然执行的可执行文件不同的，但两问的父进程都是shell，此处没有创建新的shell，自然pid也是不变的。





通常，在系统调用fork之后，子进程使用系统调用 exec，以用新程序来取代进程的内存空间。系统调用 exec加载二进制文件到内存中（破坏了包含系统调用 exec的原来程序的内存内容），并开始执行。采用这种方式，这两个进程能相互通信，并能按各自方法运行。父进程能够创建更多子进程，或者如果在子进程运行时没有什么可做，那么它采用系统调用 wait把自己移出就绪队列，直到子进程终止。因为调用 exec用新程序覆盖了进程的地址空间，所以调用 exec除非出现错误，不会返回控制。

 

![图示  描述已自动生成](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/clip_image001.gif)

fork() exec() wait() 这一套“组合拳”也和shell的设计思想相吻合。shell本质上也是一个程序，它显示一个命令提示符prompt，提示用户输入。当用户输入指令之后，shell可以从文件系统中找到这个可执行程序，调用fork()创建新进程，并调用exec()的某个变体来执行这个可执行程序，调用wait()等待该命令完成。子进程执行结束后，shell从wait()返回并再次输出一个提示符，等待用户输入下一条命令。

除此之外，shell实现结果重定向的方式也很简单，例如下面的代码，完成统计testfile.c中的字符，并且输出到newfile.txt文件之中。

![image-20221119102324332](https://shu-silence.oss-cn-shanghai.aliyuncs.com/img/2022/image-20221119102324332.png)

这种分离fork()及exec()的做法确实更有利于构建shell，因为这给了shell在fork之后，exec之前运行代码的机会，而正是fork与exec之间“夹着”的这些代码，可以在exec运行新程序前改变环境，从而让一系列有趣的功能很容易实现。当完成子进程的创建后，shell在调用exec()之前先关闭了标准输出stdout，打开了文件newfile.txt。这样，即将运行的程序 wc 的输出结果就被发送到该文件，而不是打印谁屏幕上。

当然，fork这种创建进程的写法似乎完全不同于我们之前所熟悉的方式，不过fork()、exec()、wait()这样的组合十分强大，从Linux设计哲学上说，“小程序集合而成的大型应用程序比单个的大程序更灵活，也更为实用”，这三个系统调用完美的诠释了这样的思想。



## 5.4

### 体会

在此处报告中，许多问题的解决都是源自于官方文档，更是体会到常说的RTFM(Read the Friendly Mannul)的正确性。这句话通常用在回复那些只要查阅文件就可以解决，拿出来提问只是浪费别人时间的问题。这个感受在做系统调用的功能简述时尤为深刻，许多只需要查阅官方文档的简单问题，在搜索引擎上，各种奇怪的博客或者、论坛上被回答的千奇百怪。而以操作系统课上接触的man手册、c语言官方文档cppreference、开源社区维护工具TLDR等等，不仅仅权威，而且质量更高。

对这一点感触最深的是在做main函数相关的那道题上，这道题我的参考全部来源于cppreference官方文档，在读懂文档的前提下，我自己设计程序对于官方文档提到的内容进行验证，以确保真正理解了内部的原理。而反观仅仅将问题扔到互联网上查找答案，尤其是在某些质量较差的问答论坛上，对于某些问题的回答帖子只是仅仅对于别人的回答进行了“fork”，而这种fork导致的结果是，如果父进程的资源有错的话，那所有“fork”出来的子进程也均包含错误。大家都互相抄，一份本身就质量不高的回答反复的占用搜索引擎内容之中的“资源”。在这样一个不好的氛围里寻找思路与答案，是对时间的一种浪费。

而对文档读的更加细致，越能感受到文档作者的设计思想与智慧

客观来讲，上操作系统课程、完成操作系统报告的确锻炼了自我解决问题的能力。遇到问题去查文档，RTFM，而不是总是想着去问，毕竟许多问题在自己遇到之前一定也有其他人已经遇到过，自己动手解决问题得到的对于问题的体会一定更深，收获也更加的大。

做每一道题的时候,

而当使用搜索引擎搜索相关信息时，使用英文关键词得到的结果质量的确更高。







# 等待完善的部分

3.1

3.2 死锁安全状态

与wait关系，只写了与exit关系